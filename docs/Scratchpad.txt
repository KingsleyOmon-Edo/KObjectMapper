//  Algo
        //  Might need to convert MappingService methods from stateless static class to one with instance methods
        //  =================================================================
        //  1) By extract interface refactoring, move WriteToProperties to an interface, IMutator
        //  to model the behavior of an object mutator.
        //  2) Test for regressions.
        //  2) Via "Move to another type" or "method object" refactoring, MutableWriteStrategy, make this new type,
        //  the default implementation of IMutator.WriteToProperties<T>(). Test for regressions.
        //  3) Modify the signature to relax the constraint that source and target types should be of the same type  T
        //  4) Test for regressions. Fix if necessary
        //  5) Take with the interface and default implementation, as a guide provide another implementation for immutable types.
        //  Call this ImmutableWriteStrategy
        //  6) Test to confirm that the above object model could effectively write props for all common types.
        //  7) Test that collections - IEnumerable<T> also work.
        //  8) Now implement a factory that uses C#'s new type switching switch statement, to select based on types what strategy to supply at runtime
        //  based on the type of the "target" type. Use the MutableWriterStrategy as the default case or discard.
                       
        //  LIKELY LOCATION OF CHANGES
        //  ----------------------------
        /*  Given there are different ways to alter types based on
             *  whether they are mutable or immutable, classes, records,
             *  I need a different strategy for each type.
             *
             *  Option 1:
             *  ----------
             *  So using the "strategy design" pattern encapsulate the
             *  respective write algorithms, one each for classes, records,
             *  structs, etc. Or if I choose to classify types as mutable
             *  and immutable, then one each for mutable types and immutable types.
             *
             *  Then next we need a means of dynamically selecting from amongst these
             *  respective strategies. We could use the "factory design pattern" for this.
             *  The factory would implement the strategy selection logic thus fulfilling the
             *  selector responsibility.
             *
             *  The factory would need to determine the types and other relevant characteristics
             *  of the supplied objects, to make the selection decision. Then it determines
             *  and returns the right strategy for the given object.
             *
             *  This method would simply just invoke the strategy passing the supplied object(s).
             *  Hopefully, with minimal changes to the rest of the system.
             */
             
             
      